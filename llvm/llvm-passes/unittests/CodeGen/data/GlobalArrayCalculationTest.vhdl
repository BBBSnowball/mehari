-- generated by Mehari
library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_unsigned.all;
use ieee.math_real.ALL;
use ieee.numeric_std.all;

library work;
use work.float_helpers.all;
use work.test_helpers.all;

entity test is
   port ( 
         aclk : in std_logic;
         reset : in std_logic;
         a_0_out_data : out  std_logic_vector(63 downto 0);
         a_0_out_valid : out std_logic;
         a_0_out_ready : in std_logic;
         a_1_out_data : out  std_logic_vector(63 downto 0);
         a_1_out_valid : out std_logic;
         a_1_out_ready : in std_logic;
         b_0_in_data : in  std_logic_vector(63 downto 0);
         b_0_in_valid : in std_logic;
         b_0_in_ready : out std_logic;
         b_2_out_data : out  std_logic_vector(63 downto 0);
         b_2_out_valid : out std_logic;
         b_2_out_ready : in std_logic
   );
end entity;

architecture arch of test is
   component float_add is
      port ( 
         aclk : in std_logic;
         s_axis_a_tdata : in  std_logic_vector(63 downto 0);
         s_axis_b_tdata : in  std_logic_vector(63 downto 0);
         m_axis_result_tdata : out  std_logic_vector(63 downto 0);
         s_axis_a_tvalid : in std_logic;
         s_axis_b_tvalid : in std_logic;
         m_axis_result_tvalid : out std_logic;
         s_axis_a_tready : out std_logic;
         s_axis_b_tready : out std_logic;
         m_axis_result_tready : in std_logic
   );
   end component;

signal t0_data :  std_logic_vector(63 downto 0);
signal t0_valid : std_logic;
signal t0_ready : std_logic;
signal t0_data_1 :  std_logic_vector(63 downto 0);
signal t0_valid_1 : std_logic;
begin
   a_0_out_data <= to_float(1.500000);
   a_0_out_valid <= '1';
   a_1_out_data <= b_0_in_data;
   a_1_out_valid <= b_0_in_valid;
   t0_data <= t0_data_1;
   t0_valid <= t0_valid_1;
   t0: float_add
      port map ( aclk => aclk,
                 m_axis_result_tdata => t0_data_1,
                 m_axis_result_tready => t0_ready,
                 m_axis_result_tvalid => t0_valid_1,
                 s_axis_a_tdata => to_float(1.500000),
                 s_axis_a_tvalid => '1',
                 s_axis_b_tdata => to_float(2.000000),
                 s_axis_b_tvalid => '1');
   b_2_out_data <= t0_data;
   b_2_out_valid <= t0_valid;
   b_0_in_ready <= a_1_out_ready;
   t0_ready <= b_2_out_ready;
end architecture;

