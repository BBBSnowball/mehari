ext.ROOT   = file(".")
ext.FILES  = file("files")
ext.ROOTFS = file("_install")

task checkSubmodules << {
	["busybox", "linux-xlnx", "reconos", "u-boot-xlnx"].each { source_dir ->
		if (!file(source_dir).isDirectory()) {
			logger.error(heredoc("""
				I need several gits with source code. At least '$source_dir' is missing.
				  If you have received this as part of a git, init and update the submodules
				    git submodule init reconos/{busybox,linux-xlnx,reconos,u-boot-xlnx}
				    git submodule update
				  If you cannot use submodules, clone the gits individually:
				    git clone git://git.busybox.net/busybox             busybox     -b 8d3efaf
				    git clone https://github.com/Xilinx/linux-xlnx.git  linux-xlnx  -b efc2750
				    git clone git@github.com:pc2/mehari-private.git     reconos     -b 9ca99b6
				    git clone https://github.com/Xilinx/u-boot-xlnx.git u-boot-xlnx -b 4cb9c3d
				"""))
			throw new GradleException("Source code directory $source_dir is missing.")
		}
	}
}

def hostHasIp(ip) {
	return sh_test("ifconfig | grep -q \"inet addr6\\?:$ip[/ ]\"") == 0
}

def canPing(host) {
	return sh_test("ping -c1 \"$host\" >/dev/null") == 0
}

task checkHostIp {
	description "make sure this host responds to the host IP"

	requiredProperty "host_ip"

	doLast {
		if (!hostHasIp(host_ip) || !canPing(host_ip)) {
			logger.error(heredoc("""
				ERROR: Host IP is $host_ip, but none of your interfaces has that IP.
				  You have several options:
				  - set $host_ip as static IP in your network settings
				  - manually set an additional IP for one of your interfaces:
				    sudo ifconfig eth0:1 $host_ip up
				    Please make sure that your network management software doesn't interfere.
				    In our tests, we had to stop the network-manager daemon. You also have to
				    make sure that the interface isn't taken down, i.e. don't pull out the
				    ethernet cable and connect it via a switch. If you directly connect it to
				    the board, the connection will be reset.
				  - Change the IPs that we use:
				    - use -Phost_ip=... argument on the command-line
				    - set host_ip=... in gradle-${environmentName}.properties
				  - only build and don't run it
				"""))
			throw new GradleException("This host doesn't have the IP $host_ip.")
		}
	}
}

apply plugin: ReconosPlugin

task reconosConfig {
	dependsOn checkSubmodules
	mustRunAfter "cleanReconos"

	recommendedProperty "xilinx_settings_script"
	recommendedProperty "xilinx_version"

	ext.reconos_config = project.defaultReconosConfig
	ext.reconosConfigScript = project.reconosConfigScript
	ext.reconosConfigScriptEscaped = project.reconosConfigScriptEscaped

	usesProperties "xilinx_settings_script", "xilinx_version", "gnutools", "libc_dir"
	outputs.file reconos_config

	// This task can never be up-to-date because it has to set variables for other tasks.
	outputs.upToDateWhen { false }

	ext.xil_tools = null
	ext.xilinx_settings_script = null
	ext.gnutools = null
	ext.libc_dir = null

	doLast {
		def env = System.getenv()

		// see ReconosPlugin
		xil_tools = project.xilinxDirectory
		xilinx_settings_script = project.xilinxSettingsScript
		gnutools = project.xilinxGnutools
		libc_dir = project.xilinxLibcDir

		doCheckLibc(libc_dir)

		reconos_config.withWriter { out ->
			out.writeLine("xil_tools=\"$xil_tools\"")
			out.writeLine("gnutools=\"$gnutools\"")
			out.writeLine("libc_dir=\"$libc_dir\"")
			out.writeLine("reconos_arch=\"zynq\"")
			out.writeLine("reconos_os=\"linux\"")
			out.writeLine("reconos_mmu=true")
			out.writeLine("")
			out.writeLine("export KDIR=\"$ROOT/linux-xlnx\"")
			out.writeLine("export PATH=\"$ROOT/u-boot-xlnx/tools:\$PATH\"")
		}
	}
}

def doCheckLibc(libc_dir) {
	// make sure we have the most important libc files

	if (!libc_dir.isDirectory())
		throw new GradleException("$libc_dir must be set to the install directory of libc, but it doesn't exist")

	for (file_pattern in ["usr/bin/getent", "lib/libutil.so.*", "lib/libc.so.*", "lib/ld-linux.so.*",
				 "lib/libgcc_s.so.*", "lib/libcrypt.so.*", "usr/lib/libnss_files.so"]) {
		FileTree tree = fileTree(dir: libc_dir)
		tree.include file_pattern
		if (tree.isEmpty()) {
			logger.error(heredoc("""
				ERROR: \$libc_dir must be set to the install directory of libc
				       At least the file '$file_pattern' is missing.
				       Please make sure that you install a complete libc (e.g. eglibc)
				       at this location. You have to provide more than the files I ask for!
				       \$libc_dir is '$libc_dir'
				"""))
			throw new GradleException("libc is incomplete.")
		}
	}
}

task checkLibc {
	dependsOn reconosConfig

	doLast {
		doCheckLibc(reconosConfig.libc_dir)
	}
}

task checkDigilentDriverSimple {
	dependsOn reconosConfig

	doLast {
		if (project.sh_test("find ~/.cse -name libCseDigilent.so >/dev/null") != 0) {
			logger.warning(heredoc("""
				WARNING: I cannot find the Digilent JTAG driver in ~/.cse. It may live in another location.
				         If you are sure that it works, you can ignore this warning. You can run these commands to
				         install it (adapt the path as appropriate):
				           cd /opt/Xilinx/14.7/ISE_DS/ISE/bin/lin64/digilent
				           sudo ./install_digilent.sh
				           sudo chown -R "$USER" ~/.cse
				           sudo cp -r ~/.cse ~some_user/
				           sudo chown -R some_user ~some_user/.cse
				"""))
		}
	}
}

task checkDigilentDriver {
	dependsOn checkDigilentDriverSimple

	doLast {
		// The Digilent driver installer makes ~/.cse owned by root (or probably we shouldn't
		// have run it with sudo). xmd tries to put a temporary file into it and fails. Therefore,
		// we fix this.
		def env = System.getenv()
		def cse_dir = path(env["HOME"], ".cse")
		if (cse_dir.exists() && doesFileBelongToRoot(cse_dir) && env["USER"] != "root") {
			// try to fix permissions
			logger.warn("Permissions on $cse_dir are wrong (it belongs to root). I will try to fix that.")
			sh('chown -R "$USER" ~/.cse')
		}
	}
}

task checkBeforeCompile {
	dependsOn checkSubmodules, checkLibc, checkHostIp, checkDigilentDriver
}

task cleanUboot    << { cleanGitRepository("u-boot-xlnx") }
task cleanKernel   << { cleanGitRepository("linux-xlnx") }
task cleanBusybox  << { cleanGitRepository("busybox") }
task cleanDropbear << { cleanWithDistclean("dropbear") }
task cleanReconos  << { cleanGitRepository("reconos") }
task cleanRootfs(type: Delete) { delete ROOTFS }
task cleanZlib(type: Delete) { delete { tasks["extractZlibSource"].targetDir } }
task cleanSftp(type: Delete) { delete { tasks["extractSftpSource"].targetDir } }

task clean {
	dependsOn cleanUboot, cleanKernel, cleanBusybox, cleanDropbear, cleanZlib, cleanSftp, cleanReconos, cleanRootfs
}

task patchUboot(type: PatchTask) {
	patch path(FILES, 'u-boot-xlnx-zynq.patch'), "-p1"
	workingDir file("u-boot-xlnx")
	resetWithGit()

	mustRunAfter cleanUboot
}

task applyConfigToUboot(type: SedTask) {
	expression "s/^#define CONFIG_IPADDR\\b.*\$/#define CONFIG_IPADDR   $board_ip/",
		"s/^#define CONFIG_SERVERIP\\b.*\$/#define CONFIG_SERVERIP $host_ip/",
		"s/\\bethaddr=[0-9a-fA-F:]\\+\\\\0/ethaddr=$board_mac_address\\\\0/"
	workOn file("u-boot-xlnx/include/configs/zynq_common.h")

	mustRunAfter patchUboot

	requiredProperty "board_ip"
	requiredProperty "host_ip"
	requiredProperty "board_mac_address"
}

task compileUboot(type: CrossCompileMakeTask) {
	target "zynq_zed"
	workingDir file("u-boot-xlnx")

	dependsOn patchUboot, applyConfigToUboot

	inputs.files filesInGit("u-boot-xlnx")
	outputs.files fileTree("u-boot-xlnx") {
		//include "*.o", "*.su"
		include "u-boot"		// used by downloadImagesToZynq
		include "tools/mkimage"	// used by compileKernelImage

		// some more files (but not all)
		include "u-boot.bin"
		include "u-boot.lds"
		include "u-boot.map"
		include "u-boot.srec"
		include "System.map"
		include "tools/gen_eth_addr", "tools/img2srec", "tools/kernel-doc/docproc",
			"tools/mkenvimage", "tools/mkimage", "tools/proftool"

	}
}

task configureKernel(type: CrossCompileMakeTask) {
	target "xilinx_zynq_defconfig"
	workingDir file("linux-xlnx")

	mustRunAfter cleanKernel
}
task compileKernelImage(type: CrossCompileMakeTask) {
	target "uImage", "LOADADDR=0x00008000"
	workingDir file("linux-xlnx")
	dependsOn configureKernel
	// U-boot has the mkimage tool we need to package the kernel, so we have to build that first
	dependsOn compileUboot

	inputs.files filesInGit("linux-xlnx")
	inputs.file rootPath("linux-xlnx", ".config")
	outputs.files fileTree("linux-xlnx") {
		include "arch/arm/boot/uImage"
		include "scripts/dtc/dtc"	//TODO is it build by this?
	}
}
task compileKernelModules(type: CrossCompileMakeTask) {
	target "modules"
	workingDir file("linux-xlnx")
	dependsOn configureKernel
	shouldRunAfter compileKernelImage

	inputs.files filesInGit("linux-xlnx")
	inputs.file rootPath("linux-xlnx", ".config")
	outputs.files fileTree("linux-xlnx") {
		include "**/*.ko"
		include "**/modules.order", "**/modules.builtin"
	}
}

task compileKernel() {
	dependsOn configureKernel, compileKernelImage, compileKernelModules
}

task copyBusyboxConfig(type: Copy) {
	from(FILES) {
		include "busybox-config"
		rename "busybox-config", ".config"
	}
	into rootPath("busybox")

	mustRunAfter cleanBusybox
}

task applyConfigToBusybox(type: SedTask) {
	expression "s#^CONFIG_PREFIX=.*#CONFIG_PREFIX=\\\"${ROOTFS.toString().replace("#", "\\#")}\\\"#"
	workOn rootPath("busybox", ".config")

	dependsOn copyBusyboxConfig
}

task compileBusybox(type: CrossCompileMakeTask) {
	target ""
	dependsOn copyBusyboxConfig, applyConfigToBusybox
	workingDir rootPath("busybox")

	inputs.files filesInGit("busybox")
	outputs.files fileTree("busybox") {
		include "busybox"
		include "busybox.links"
		include "**/*.a"
	}
}

def configureDropbearCommandline() {
	def host = getCrosscompileHostSpecAfterReconosConfig()
	return ["./configure", "--prefix=$ROOTFS", "--host=$host",
		"--enable-bundled-libtom", "--disable-utmp", "--disable-zlib"]
}

task configureDropbear(type: Exec) {
	dependsOn reconosConfig
	workingDir rootPath("dropbear")

	inputs.files fileTree("dropbear") {
		include "config*"
		exclude "config.h" ; exclude "config.log" ; exclude "config.status"
	}
	inputs.property("commandLine") { configureDropbearCommandline() }
	outputs.file file("dropbear/Makefile")
	outputs.file file("dropbear/config.h")

	doFirst {
		commandLine "bash", "-c", ". ${reconosConfig.reconosConfigScriptEscaped} && " +
			escapeForShell(configureDropbearCommandline())
	}

	mustRunAfter cleanDropbear
}

task applyConfigToDropbear {
	// We could modify options.h

	dependsOn configureDropbear
}

def dropbearConfig = ["PROGRAMS=dropbear dbclient dropbearkey dropbearconvert scp", "SCPPROGRESS=1"]

task compileDropbear(type: CrossCompileMakeTask) {
	target dropbearConfig
	workingDir rootPath("dropbear")
	prependPATH getCrosscompileToolchainDirAfterReconosConfig()

	dependsOn applyConfigToDropbear

	inputs.files fileTree("dropbear") {
		exclude "**/*.log", "**/*.o", "**.a", "**/*.obj", "**/*.exe", "**/*.lib", "**/*.dll"
		exclude "**/*.da", "**/*.bb", "**/*.bbg", "**/*.prof", "**/*.gcov", "**/*~"
		exclude "**/*.ps", "**/*.pdf", "**/.xvpics"
		exclude "dropbear", "dbclient", "dropbearkey", "dropbearconvert", "scp", "scp-progress", "dropbearmulti"

		// removed by distclean, but nonetheless input to compile:
		// config.h, Makefile

		exclude(["test", "ltmtest", "mpitest", "mtest/mtest", "mtest/mtest.exe", "tommath.tex"].collect({
			item -> path("libtommath", item).toString()
		}))
		def excludeInLibtommathEtc = ["pprime", "tune", "mersenne", "drprime", "tune86", "tune86l", "mont",
			"2kprime", "pprime.dat"]
		excludeInLibtommathEtc = excludeInLibtommathEtc.collect { item -> path("libtommath", "etc", item).toString() }
		exclude(*excludeInLibtommathEtc)
		exclude "**/*.dyn", "**/*.dpi", "**/*.lo", "**/*.la"
		exclude "**/*.bat", "**/*.pdf"
		exclude "**/.libs"
	}
	outputs.files fileTree("dropbear") {
		include "dropbear", "dbclient", "dropbearkey", "dropbearconvert"
		// include "scp", "scp-progress", "dropbearmulti"
	}
}

task extractZlibSource(type: FetchAndExtractSourceTask) {
	artifact "net.zlib:zlib:1.2.8:sources@tar.gz"
	into "_zlib"

	mustRunAfter cleanZlib
}

task extractSftpSource(type: FetchAndExtractSourceTask) {
	artifact "org.openssh:openssh:5.9p1:sources@tar.gz"
	into "_sftp"

	mustRunAfter cleanSftp
}

def configureZlibCommandline() {
	def host = getCrosscompileHostSpecAfterReconosConfig()
	return "CC=${host}-gcc " + escapeForShell(["./configure", "--prefix=$ROOTFS"])
}

task configureZlib(type: Exec) {
	dependsOn extractZlibSource, reconosConfig
	workingDir extractZlibSource.targetDir

	inputs.files fileTree(extractZlibSource.targetDir) {
		include "config*"
		exclude "config.h" ; exclude "config*.log" ; exclude "config*.status"
	}
	inputs.property("commandLine") { configureSftpCommandline() }
	outputs.file path(extractZlibSource.targetDir, "Makefile")
	outputs.file path(extractZlibSource.targetDir, "config.h")

	doFirst {
		commandLine "bash", "-c", ". ${reconosConfig.reconosConfigScriptEscaped} && " +
			configureZlibCommandline()
	}
}

task compileZlib(type: CrossCompileMakeTask) {
	target ""
	workingDir extractZlibSource.targetDir
	prependPATH getCrosscompileToolchainDirAfterReconosConfig()

	dependsOn configureZlib

	inputs.files fileTree(extractZlibSource.targetDir) {
		include "**/*.c", "**/*.h", "Makefile"
		exclude "contrib", "examples"
	}
	outputs.files fileTree(extractZlibSource.targetDir) {
		include "libz.a", "libz.so*"
	}
}

task installZlib(type: CrossCompileMakeTask) {
	target "install"
	workingDir extractZlibSource.targetDir
	prependPATH getCrosscompileToolchainDirAfterReconosConfig()

	dependsOn compileZlib

	inputs.files compileZlib.outputs
	inputs.file path(extractZlibSource.targetDir, "zlib.h")
	inputs.file path(extractZlibSource.targetDir, "zconf.h")
	outputs.files fileTree(ROOTFS) {
		include "lib/libz**"
		include "include/zlib.h"
		include "include/zconf.h"
	}
}

def configureSftpCommandline() {
	def host = getCrosscompileHostSpecAfterReconosConfig()
	return ["./configure-sftp", "--prefix=$ROOTFS", "--host=$host",
		"--disable-utmp", "--disable-utmpx", "--disable-wtmp", "--disable-wtmpx",
		"--with-zlib=$ROOTFS", "--without-openssl-header-check"]
}

task configureSftp {
	dependsOn extractSftpSource, reconosConfig, installZlib

	ext.sources = ["sftp-common.c", "sftp-server.c", "sftp-server-main.c", "buffer.c", "bufaux.c",
		"xmalloc.c", "log.c", "misc.c", "openbsd-compat/getopt.c", "openbsd-compat/strlcat.c",
		"openbsd-compat/strtonum.c", "openbsd-compat/strlcpy.c", "openbsd-compat/port-tun.c",
		"openbsd-compat/strmode.c", "openbsd-compat/pwcache.c", "openbsd-compat/fmt_scaled.c",
		"openbsd-compat/bsd-misc.c", "fatal.c", "openbsd-compat/vis.c"]

	doLast {
		// The configure script demands too many dependencies. Fortunately, we know that we have
		// all the dependencies we need, so we don't configure at all.

		// However, we have to fake a few headers because they are included (but never used).
		path(extractSftpSource.targetDir, "openssl").mkdirs()
		path(extractSftpSource.targetDir, "openssl", "opensslv.h").write("")
		path(extractSftpSource.targetDir, "openssl", "bn.h").write("#define BIGNUM int")
		path(extractSftpSource.targetDir, "config.h").write("")

		// We use a Makefile, but we have to create it ourselves.
		path(extractSftpSource.targetDir, "Makefile-sftp").withWriter { out ->
			def cflags = "-g -O2 -Wall -Wpointer-arith -Wuninitialized -Wsign-compare -Wformat-security -Wno-pointer-sign -Wno-unused-result -fno-strict-aliasing -fno-builtin-memset -fstack-protector-all -DHAVE_CONFIG_H -I. -I.. -I. -I./.. -I" + escapeForShell(path(ROOTFS, "include"))
			def ldflags = "-L" + escapeForShell(path(ROOTFS, "lib"))

			out.writeLine("%.o: %.c")
			out.writeLine("\tarm-xilinx-linux-gnueabi-gcc $cflags -c \$< -o \$@")
			out.writeLine("")

			out.writeLine("sftp-server: " + sources*.replace(".c", ".o").join(" "))
			out.writeLine("\tarm-xilinx-linux-gnueabi-gcc $ldflags -o \$@ \$^ -ldl -lutil -lnsl")
		}

		// We still have to run configure to create the config.h file. However, we modify it a bit, so it
		// won't complain about missing OpenSSH libraries.
		exec {
			commandLine "sh", "-c", "sed " + escapeForShell('s/^\\s*as_fn_error.*\\bOpenSSL\\b.*[0-9]\\+\\s*\$/true/') +
				"<configure >configure-sftp"
			workingDir extractSftpSource.targetDir
		}

		chmod(path(extractSftpSource.targetDir, "configure-sftp"), 0755)

		exec {
			commandLine "bash", "-c", ". ${reconosConfig.reconosConfigScriptEscaped} && " +
				escapeForShell(configureSftpCommandline())
			workingDir extractSftpSource.targetDir
		}
	}

	inputs.files fileTree(extractSftpSource.targetDir) {
			include "config*"
			exclude "config.h" ; exclude "config.log" ; exclude "config.status"
	}
	inputs.property("commandLine") { configureSftpCommandline() }

	outputs.dir path(extractSftpSource.targetDir, "openssl")
	outputs.file path(extractSftpSource.targetDir, "config.h")
	outputs.file path(extractSftpSource.targetDir, "configure-sftp")
	outputs.file path(extractSftpSource.targetDir, "Makefile-sftp")
}

task compileSftp(type: CrossCompileMakeTask) {
	target "-f", "Makefile-sftp", "sftp-server"
	workingDir extractSftpSource.targetDir
	prependPATH getCrosscompileToolchainDirAfterReconosConfig()

	dependsOn configureSftp

	inputs.files configureSftp.sources.collect { source -> rootPath(extractSftpSource.targetDir, source.split("/")) }
	inputs.file rootPath(extractSftpSource.targetDir, "Makefile-sftp")
	outputs.file rootPath(extractSftpSource.targetDir, "sftp-server")
}

task compileReconosDriver(type: CrossCompileMakeTask) {
	target ""
	workingDir rootPath("reconos", "linux", "driver")
}
task compileReconosLib(type: CrossCompileMakeTask) {
	target ""
	workingDir rootPath("reconos", "linux", "lib")
}
task compileReconosDemoLinux(type: CrossCompileMakeTask) {
	target ""
	ext.demo = "sort_demo"
	ext.demoDir = rootPath("reconos", "demos", demo)
	workingDir path(demoDir, "linux")

	//requiredProperty "demo"

	dependsOn compileReconosLib
}

def demoHwDir(...suffix) {
	def demoDir = compileReconosDemoLinux.demoDir
	return rootPath(demoDir, "hw", *suffix)
}

reconosHardwareTest("ReconosDemoHardware") {
	hardwareDir demoHwDir()

	prepare {
		mustRunAfter cleanReconos

		excludeOutput "device_tree.dts", "device_tree.dtb"
		excludeOutput "ps7_init.tcl"
	}
}

task copyReconosDeviceTree(type: Copy) {
	def demo = compileReconosDemoLinux.demo
	from path(FILES, "device_tree.dts")
	into demoHwDir("edk_zynq_linux")
}

def nfsMountForDeviceTree() {
	if (hasProperty("nfs_mount"))
		return project.nfs_mount
	else
		return "$host_ip:$local_nfs_root"
}

task applyConfigToReconosDeviceTree(type: SedTask) {
	expression { [
		/s#\(nfsroot=[0-9.]\+\):[^,]*,tcp#nfsroot=/ + nfs_mount + /,tcp#/,
		/s#\bip=[0-9.]\+:#ip=/ + board_ip + /:#/ ] }
	workOn demoHwDir("edk_zynq_linux", "device_tree.dts")

	dependsOn copyReconosDeviceTree
	requiredProperty "board_ip"
	requiredProperty "nfs_mount"
}

task prepareReconosDeviceTree {
	dependsOn copyReconosDeviceTree, applyConfigToReconosDeviceTree
}

task compileReconosDeviceTree(type: Exec) {
	//TODO depend on the task that builds dtc
	dependsOn reconosConfig, prepareReconosDeviceTree, prepareReconosDemoHardware

	workingDir demoHwDir("edk_zynq_linux")

	commandLine rootPath("linux-xlnx", "scripts", "dtc", "dtc"),
		"-I", "dts", "-O", "dtb", "-o", "device_tree.dtb", "device_tree.dts"
}

task compileReconosDemoHardware {
	dependsOn compileReconosDemoHardwareBitstream, compileReconosDeviceTree
}

task compileReconos {
	dependsOn compileReconosDriver, compileReconosLib, compileReconosDemoLinux, compileReconosDemoHardware
}

task compile {
	dependsOn compileUboot, compileKernel, compileBusybox, compileDropbear, compileReconos

	shouldRunAfter checkBeforeCompile
}

task installBusybox(type: CrossCompileMakeTask) {
	target "CONFIG_PREFIX=$ROOTFS", "install"
	workingDir rootPath("busybox")

	dependsOn compileBusybox
	shouldRunAfter compile

	doLast {
		def tempfile_not_ignored = rootPath("busybox",  "busybox.links")
		def tempfile_ignored     = rootPath("busybox", ".busybox.links")
		if (tempfile_not_ignored.exists()) {
			// hide this file, so it doesn't make the git dirty
			// (unfortunately, it is not ignored in .gitignore)
			tempfile_not_ignored.renameTo(tempfile_ignored)
		}
	}
}

def getInitInfo(file, key) {
	project.file(file).withReader { rd ->
		boolean inInitInfo = false
		String line = null
		while ((line = rd.readLine()) != null) {
			if (line ==~ /^#+\s*BEGIN INIT INFO\s*$/)
				inInitInfo = true
			else if (line ==~ /^#+\s*END INIT INFO\s*$/)
				return null
			else if (inInitInfo) {
				def m = (line =~ /(?i)^#\s*/ + project.escapeForRegex(key) + /:\s*(.*)$/)
				if (m)
					return m.group(1).trim()
			}
		}
		return null
	}
}

def getOrder(file, start_or_stop) {
	def order = getInitInfo(file, "${start_or_stop}-order")
	if (order)
		return order
	else {
		order = getInitInfo(file, "order")

		if (start_or_stop == "start")
			return order
		else {
			if (order)
				return String.format("%02d", 100 - order.toInteger())
			else
				return ""
		}
	}
}

import groovy.io.FileType

task installBaseSystem {
	requiredProperty "host_ip"

	doLast {
		for (dir in ["dev", "dev/pts",
				"etc", "etc/init.d", "etc/rc.d", "etc/default",
				"lib", "mnt", "opt", "proc", "root", "sys", "tmp",
				"var","var/run", "var/log"])
			path(ROOTFS, *dir.split("/")).mkdirs()

		def rc_script = path(ROOTFS, "etc", "rcS")
		project.copyFile(path(FILES, "startup-script.sh"), rc_script)
		chmod(rc_script, 0755)
		project.copyFile(path(FILES, "inittab"), path(ROOTFS, "etc", "inittab"))
		project.copyFile(path(FILES, "fstab"  ), path(ROOTFS, "etc", "fstab"  ))

		for (dir in ["init.d", "rc.d"]) {
			path(ROOTFS, "etc", dir).deleteDir()
			path(ROOTFS, "etc", dir).mkdir()
		}

		path(FILES, "init.d").eachFile(FileType.FILES) { initd_script ->
			def src = initd_script
			def name = src.name
			def dst = path(ROOTFS, "etc", "init.d", name)
			project.copyFile(src, dst)
			chmod(dst, 0755)

			def start_order = getOrder(dst, "start")
			def stop_order  = getOrder(dst, "stop")

			if (start_order)
				project.symlink(dst, path(ROOTFS, "etc", "rc.d", "S${start_order}${name}"))

			if (stop_order)
				project.symlink(dst, path(ROOTFS, "etc", "rc.d", "K${stop_order}${name}"))
		}

		path(ROOTFS, "etc", "default", "notify-host").withWriter { out ->
			out.writeLine("NOTIFY_HOST=" + escapeForShell(host_ip))
		}


		path(ROOTFS, "etc", "passwd").withWriter { out ->
			out.writeLine("root:x:0:0:root:/root:/bin/ash")
		}
		path(ROOTFS, "etc", "group").withWriter { out ->
			out.writeLine("root:x:0:")
		}

		// see http://cross-lfs.org/view/clfs-sysroot/arm/cross-tools/eglibc.html
		path(ROOTFS, "etc", "nsswitch.conf").withWriter { out ->
			out.write(heredoc("""
				passwd: files
				group: files
				shadow: files

				hosts: files dns
				networks: files

				protocols: files
				services: files
				ethers: files
				rpc: files
				"""))
		}
		
		project.copyFile(path("/etc/localtime"), path(ROOTFS, "etc", "localtime"))

		// eglibc doc (see above) suggest that we add `/usr/local/lib` and `/opt/lib`,
		// but we don't use them
		touch(path(ROOTFS, "etc", "ld.so.conf"))
	}
}

//TODO Copy tasks cannot handle symlinks, so we may want to switch to something else. However,
//     we only have about 40 symlinks in /lib and /usr/lib.
task installLibc(type: Copy) {
	dependsOn reconosConfig

	from { reconosConfig.libc_dir }
	into ROOTFS

	exclude "usr/include"

	// We do not copy all the locales (which are many times bigger than the whole rootfs), so we prepare
	// a list of the locales we do want.
	// Actually, there is more locale data in /usr/share/locale, but this is small, so we don't care.
	ext.includedLocales = ["en_US", "en_US.utf8", "de_DE.utf8"]
	exclude {
		def m = (it.relativePath =~ "^usr/(lib/)?locale/([^/]+).*")
		def shouldExclude = (m && !includedLocales.contains(m[0][2]))
		println("${shouldExclude?'exclude':'include'} ${it.relativePath}")
		return shouldExclude
	}
}

task installDropbearFiles(type: CrossCompileMakeTask) {
	target dropbearConfig + ["prefix="+ROOTFS, "install"]
	workingDir rootPath("dropbear")
	prependPATH getCrosscompileToolchainDirAfterReconosConfig()

	dependsOn compileDropbear
	shouldRunAfter compile

	inputs.files compileDropbear.outputs
	inputs.files fileTree("dropbear") { include "dropbear.8", "dropbearkey.1", "dbclient.1", "dropbearconvert.1" }
	outputs.files fileTree(ROOTFS) {
		include "bin/dbclient", "bin/dropbearkey", "bin/dropbearconvert", "bin/scp"
		include "sbin/dropbear"
		include "share/man/**/dropbear*", "share/man/**/dbclient*"
	}
}

task installDropbearConfig {
	mustRunAfter installDropbearFiles

	def home_dir_for_board = path(ROOTFS, "root")
	def ssh_dir = path(home_dir_for_board, ".ssh")
	def authorized_keys = path(ssh_dir, "authorized_keys")
	def home_dir = System.getenv()["HOME"]
	def public_key_file = path("$home_dir", ".ssh", "id_rsa.pub")
	def shells_file = path(ROOTFS, "etc", "shells")

	inputs.file public_key_file
	inputs.property "HOME", home_dir
	outputs.dir ssh_dir
	outputs.file authorized_keys
	outputs.file shells_file

	doLast {
		ssh_dir.mkdirs()
		if (public_key_file.exists() && !authorized_keys.exists()) {
			def public_key = public_key_file.text
			authorized_keys.write(public_key)

			chmod(home_dir_for_board, 0755)
			chmod(ssh_dir, 0755)
			chmod(authorized_keys, 0600)
		}

		def shells = ""
		if (shells_file.exists())
			shells = shells_file.text
		if (!(shells ==~ '^/bin/ash$')) {
			shells += "/bin/ash\n"
			shells_file.parentFile.mkdirs()
			shells_file.write(shells)
		}
	}
}

task installSftp(type: Copy) {
	from extractSftpSource.targetDir
	into path(ROOTFS, "usr", "libexec")

	include "sftp-server"

	 dependsOn compileSftp
}

task installDropbear {
	dependsOn installDropbearFiles, installDropbearConfig, installSftp
}

task installKernelModules(type: CrossCompileMakeTask) {
	target "INSTALL_MOD_PATH="+ROOTFS, "modules_install"
	workingDir rootPath("linux-xlnx")

	dependsOn compileKernelModules

	doLast {
		// "source" and "build" links don't make any sense on the target platform and
		// they confuse some Gradle tasks (e.g. cleanRootfs and copyFilesToNfsRoot):
		// They delete all files in linux-xlnx or truncate them.
		sh("rm -f ${escapeForShell(ROOTFS)}/lib/modules/*/{source,build}", "bash")
	}
}

task installReconos {
	dependsOn installKernelModules, compileReconosDriver, compileReconosDriver

	doLast {
		def KERNEL_RELEASE = path(ROOT, "linux-xlnx", "include", "config", "kernel.release").text.trim()
		def RECONOS_MODULE = "kernel/drivers/mreconos.ko"
		def MODULE_DIR = path(ROOTFS, "lib", "modules", KERNEL_RELEASE)
		def src = path(ROOT, "reconos", "linux", "driver", "mreconos.ko")
		def dst = path(MODULE_DIR, *RECONOS_MODULE.split("/"))
		project.copyFile(src, dst)
		path(MODULE_DIR, "modules.dep").withWriterAppend { out ->
			out.writeLine(RECONOS_MODULE + ": ")
		}
	}
}

task buildRootfs {
	dependsOn reconosConfig, installBusybox, installBaseSystem,
		installLibc, installDropbear, installKernelModules,
		installReconos

	doFirst {
		if (!ROOTFS.isDirectory())
			ROOTFS.mkdirs()
	}
}

task build {
	dependsOn compile, buildRootfs
}

// We cannot use a Copy task because it doesn't support symlinks.
/*task copyFilesToNfsRoot(type: Copy) {
	from ROOTFS
	into local_nfs_root

	requiredProperty "local_nfs_root"

	mustRunAfter buildRootfs
}*/
task copyFilesToNfsRoot(type: Exec) {
	commandLine "cp", "-afT", ROOTFS, local_nfs_root

	requiredProperty "local_nfs_root"

	mustRunAfter buildRootfs
}

def fileAncestors(file) {
	def ancestors = []
	while (file != null) {
		ancestors.add(file)
		file = file.parentFile
	}
	return ancestors
}

task fixPermissionsInNfsRoot(type: Exec) {
	def authorized_keys_file = path(local_nfs_root, "root", ".ssh", "authorized_keys")
	commandLine("chown", "root:root", *fileAncestors(authorized_keys_file).take(3))

	mustRunAfter copyFilesToNfsRoot
	requiredProperty "local_nfs_root"
}

task warnAboutAdditionalFilesInNfsRoot {
	requiredProperty "local_nfs_root"

	mustRunAfter copyFilesToNfsRoot

	doLast {
		def exclude = [".ash_history", "dropbear", "motd", "log", "run", "lost+found"]
		def exclude_pattern = "/\\(" + exclude.collect({ x -> project.escapeForRegex(x) }).join("\\|") + "\\)\\(/\\|\$\\)"
		def exclude_filter = "grep -v " + escapeForShell(exclude_pattern)

		def list_files = { directory, listfile ->
			directory = escapeForShell(directory)
			listfile = escapeForShell(listfile)
			sh("cd $directory && find | $exclude_filter | sort >$listfile")
		}

		def files_in_rootfs = rootPath(temporaryDir, "files_in_rootfs")
		def files_in_nfsroot = rootPath(temporaryDir, "files_in_nfsroot")
		try {
			list_files(ROOTFS, files_in_rootfs)
			list_files(local_nfs_root, files_in_nfsroot)

			def files_in_rootfs_esc = escapeForShell(files_in_rootfs)
			def files_in_nfsroot_esc = escapeForShell(files_in_nfsroot)
			def res = sh_test("diff -y --suppress-common-lines $files_in_rootfs_esc $files_in_nfsroot_esc")
		} finally {
			if (files_in_rootfs.exists())
				files_in_rootfs.delete()
			if (files_in_nfsroot.exists())
				files_in_nfsroot.delete()
		}
	}
}

task updateNfsRoot {
	dependsOn copyFilesToNfsRoot, fixPermissionsInNfsRoot, warnAboutAdditionalFilesInNfsRoot
}

task createPs7InitFile(type: Copy) {
	//TODO we shouldn't have to provide this file - it should be in the reconos git
	def edk_project_dir = demoHwDir("edk_zynq_linux")
	from FILES
	into edk_project_dir
	include "ps7_init.tcl"
}

task downloadImagesToZynq(type: Exec) {
	//NOTE If this fails because it doesn't find the cable, install the cable drivers:
	//     cd $XILINX/bin/lin64/digilent ; ./install_digilent.sh
	def edk_project_dir = demoHwDir("edk_zynq_linux")
	def command = escapeForShell(["bash", "zynq_boot_tftp.sh",
		path(ROOT, "linux-xlnx", "arch", "arm", "boot", "uImage"),
		path(edk_project_dir, "device_tree.dtb"),
		path(edk_project_dir, "ps7_init.tcl"),
		path(ROOT, "u-boot-xlnx", "u-boot")])
	commandLine "bash", "-c", ". ${reconosConfig.reconosConfigScriptEscaped} && $command"
	workingDir ROOT

	doLast {
		logger.info("The board should be booting, now.")
		logger.info("If you abort u-boot for some reason, enter 'jtagboot' or 'bootm 0x3000000 - 0x2A00000'.")
	}

	mustRunAfter checkHostIp, checkDigilentDriver, reconosConfig, updateNfsRoot
	// If we do this later, we may miss the 'done' message from the board.
	//TODO Listen concurrently in a Java thread and only only query the result in waitForBootingBoard.
	mustRunAfter compileReconosDemoHardwareBitstream
	dependsOn compileKernelImage, compileReconosDeviceTree, compileUboot
	dependsOn createPs7InitFile
}

task waitForBootingBoard {
	mustRunAfter downloadImagesToZynq, downloadReconosDemoHardwareBitstream
	requiredProperty "host_ip"

	doLast {
		logger.info("Wait for the board to contact us...")
		if (sh_test("timeout 120 nc -l ${escapeForShell(host_ip)} 12342") != 0) {
			logger.error(
				"ERROR: The board didn't send the 'done' message within 30 seconds.")

			if (!canPing(host_ip)) {
				logger.error(heredoc("""
					ERROR: I cannot ping $host_ip, so I think for some reason your IP got reset.
					  Please make sure that you use an ethernet switch (i.e. don't
					  directly connect your PC to the board) or make sure that the IP
					  settings survive a reset of the ethernet connection (i.e. set them
					  in NetworkManager or similar).
					"""))
				throw new GradleException("I cannot ping the local host ($host_ip).")
			}

			if (!canPing(board_ip)) {
				logger.error(
					"I cannot ping the board ($board_ip). This is a bad sign. I will try to continue anyway.")
			} else {
				logger.warn("I didn't get any reply from the board. I will try to continue anyway. " +
					"However, you should fix the underlying problem, so I won't waste time waiting " +
					" until the timeout.")
			}
		}
	}
}

task bootZynq {
	dependsOn downloadImagesToZynq, downloadReconosDemoHardwareBitstream, waitForBootingBoard
}

def getBoardPubkey(keytype) {
	def infofile = path(local_nfs_root, "etc", "dropbear", "dropbear_${keytype}_host_key.info")
	return (infofile.text =~ /(?m)^ssh-\S+\s+\S+/)[0]
}

def pubkeyIsInKnownHosts(hostname, pubkey) {
	return 0 == sh_test("ssh-keygen -F ${escapeForShell(hostname)} | grep -q ${escapeForShell(pubkey)}")
}

task prepareSsh {
	dependsOn checkHostIp
	mustRunAfter bootZynq

	requiredProperty "local_nfs_root"

	doLast {
		def pubkey = getBoardPubkey("rsa")

		if (pubkey && !pubkeyIsInKnownHosts(board_ip, pubkey)) {
			// board key is not in known_hosts, so we remove any old ones and add the new one
			sh("ssh-keygen -R ${escapeForShell(board_ip)}")
			def home_dir = System.getenv()["HOME"]
			path(home_dir, ".ssh", "known_hosts").withWriterAppend { out ->
				out.write("$board_ip $pubkey\n")
			}
			// re-hash the file
			sh("ssh-keygen -H")
		}
	}
}

task sshShell(type: MySshTask) {
	dependsOn prepareSsh

	session(remotes.board) {
		def channel=session.openChannel("shell");
		channel.setInputStream(System.in, true);                                                                                                       
		channel.setOutputStream(System.out, true);
		channel.setPty(true);
		channel.connect(3*1000);
		channel.run();
	}
}

task runDemo(type: MySshTask) {
	dependsOn prepareSsh
	
	session(remotes.board) {
		def demo_args = "2 2 50"
		def demo = compileReconosDemoLinux.demo
		def demo_binary = path(compileReconosDemoLinux.demoDir, "linux", demo)
		def demo_on_target = path("/tmp", demo)
		put(demo_binary.toString(), demo_on_target.toString())

		demo_on_target = escapeForShell(demo_on_target)
		execute("chmod +x $demo_on_target")
		execute("$demo_on_target $demo_args")
	}
}

task testSortDemoSimulation(type: Exec) {
	commandLine "./test.sh"
	workingDir rootPath("reconos", "demos", "sort_demo", "test")

	environmentFromConfig()
}
// don't waste time for synthesis, if the code doesn't work
compileReconosDemoHardwareBitstream.shouldRunAfter testSortDemoSimulation

task bootZynqAndRunDemo {
	dependsOn updateNfsRoot, bootZynq, runDemo
}

task compileAndRun {
	dependsOn checkBeforeCompile, compile, buildRootfs, bootZynqAndRunDemo
}

task cleanCompileAndRun {
	dependsOn clean, compileAndRun
}

task prepareTest {
	dependsOn buildRootfs, updateNfsRoot, bootZynq
}

task test {
	dependsOn runDemo
	dependsOn testSortDemoSimulation
}
