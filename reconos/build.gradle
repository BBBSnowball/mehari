ext.reconos_args = ["--host-ip", host_ip, "--board-ip", board_ip, "-j"+parallel_compilation_processes,
	"--nfs-mount=" + nfs_mount, "--nfs-no-sudo", "--demo=sort_demo", "--nfs-root", local_nfs_root,
	"--mac-address", board_mac_address]

/*task clean(type: Exec) {
	commandLine(["./pavement.py", "clean"] + reconos_args)

	environmentFromConfig()
}*/

/*task compile(type: Exec) {
	commandLine(["./pavement.py", "build"] + reconos_args)

	environmentFromConfig()

	mustRunAfter "clean"
}*/

task test(type: Exec) {
	commandLine(["./pavement.py", "boot_zynq_and_run_demo"] + reconos_args)

	environmentFromConfig()

	dependsOn "compile"
}




ext.ROOT   = file(".")
ext.FILES  = file("files")
ext.ROOTFS = file("_install")

//TODO move to example properties file and update it (e.g. we cannot use sudo with Gradle)
// To be honest, all those options are quite confusing, so I will try to explain them. There are two
// scenarios to consider:
// 1. Your system can run an NFS server and you can use sudo to copy the files to the NFS share
//    and chown them to root.
// 2. You don't have an NFS server on this host or you don't have root permissions.
//
// The first case is quite simple: You set host-ip and board-ip to appropriate values and run this script.
// It will export the NFS share and use sudo whenever appropriate. You may have to enter your password for
// sudo. If you want the script to run unattended, change /etc/sudoers to not require a password.
//
// In addition, you may have to change your IP settings. Simply use the host-ip and board-ip parameters
// to tell the script which addresses it should use. Only IPv4 is supported. Both IPs must be in the same
// subnet assuming a netmask of 255.255.255.0 (.../24).
//
//
// The second case needs a bit more work. You may wonder why somebody would want to jump to so many hoops, if
// they could simply use the other solution. My continuous integration runs in an LXC container and my kernel
// is too old to support NFS inside containers. Furthermore, I don't want the tests to run with root priviledges.
//
// You have to prepare the NFS server:
// (I assume the NFS server has the IP 192.168.24.20 and host-ip and board-ip are the defaults.)
//   in /etc/exports on the NFS server:
//   /media/zynq-rootfs 192.168.24.17(rw,async,all_squash,anongid=0,anonuid=0,secure,no_subtree_check) \
//                      192.168.24.23(rw,async,no_root_squash,secure,no_subtree_check)
// Make sure that an appropriate file system lives at /media/zynq-rootfs. After changing /etc/exports
// you have to run something like 'exportfs -rav'.
//
// You have to mount the NFS share on the build host, i.e.
// ssh root@192.168.24.17 mount -t nfs 192.168.24.20:/media/zynq-rootfs /nfs/zynqn -o soft,vers=3
// You should add the mount to /etc/fstab, so it will be remounted after a reboot.
//
// The mounted NFS share provides full access for every user, so you should make sure that only trusted users
// can access it, e.g. chown jenkins /nfs ; chmod 700 /nfs
//
// Use these options: --nfs-mount=192.168.24.20:/media/zynq-rootfs --nfs-no-sudo

task checkSubmodules << {
	["busybox", "linux-xlnx", "reconos", "u-boot-xlnx"].each { source_dir ->
		if (!file(source_dir).isDirectory()) {
			logger.error(heredoc("""
				I need several gits with source code. At least '$source_dir' is missing.
				  If you have received this as part of a git, init and update the submodules
				    git submodule init reconos/{busybox,linux-xlnx,reconos,u-boot-xlnx}
				    git submodule update
				  If you cannot use submodules, clone the gits individually:
				    git clone git://git.busybox.net/busybox             busybox     -b 8d3efaf
				    git clone https://github.com/Xilinx/linux-xlnx.git  linux-xlnx  -b efc2750
				    git clone git@github.com:pc2/mehari-private.git     reconos     -b 9ca99b6
				    git clone https://github.com/Xilinx/u-boot-xlnx.git u-boot-xlnx -b 4cb9c3d
				"""))
			throw new GradleException("Source code directory $source_dir is missing.")
		}
	}
}

def host_has_ip(ip) {
	return sh_test("ifconfig | grep -q \"inet addr6\\?:$ip[/ ]\"") == 0
}

def can_ping(host) {
	return sh_test("ping -c1 \"$host\" >/dev/null") == 0
}

task checkHostIp {
	description "make sure this host responds to the host IP"

	requiredProperty "host_ip"

	doLast {
		if (!host_has_ip(host_ip) || !can_ping(host_ip)) {
			logger.error(heredoc("""
				ERROR: Host IP is $host_ip, but none of your interfaces has that IP.
				  You have several options:
				  - set $host_ip as static IP in your network settings
				  - manually set an additional IP for one of your interfaces:
				    sudo ifconfig eth0:1 $host_ip up
				    Please make sure that your network management software doesn't interfere.
				    In our tests, we had to stop the network-manager daemon. You also have to
				    make sure that the interface isn't taken down, i.e. don't pull out the
				    ethernet cable and connect it via a switch. If you directly connect it to
				    the board, the connection will be reset.
				  - Change the IPs that we use:
				    - use -Phost_ip=... argument on the command-line
				    - set host_ip=... in gradle-${environmentName}.properties
				  - only build and don't run it
				"""))
			throw new GradleException("This host doesn't have the IP $host_ip.")
		}
	}
}

task reconosConfig {
	dependsOn checkSubmodules

	recommendedProperty "xilinx_settings_script"
	recommendedProperty "xilinx_version"

	ext.reconos_config = rootPath("reconos", "tools", "environment", "default.sh")
	ext.reconosConfigScript = file("reconos/tools/environment/setup_reconos_toolchain.sh")
	ext.reconosConfigScriptEscaped = escapeForShell(reconosConfigScript)

	usesProperties "xilinx_settings_script", "xilinx_version", "gnutools", "libc_dir"
	outputs.file reconos_config

	// This task can never be up-to-date because it has to set variables for other tasks.
	outputs.upToDateWhen { false }

	ext.xil_tools = null
	ext.xilinx_settings_script = null
	ext.gnutools = null
	ext.libc_dir = null

	doLast {
		def env = System.getenv()

		if (project.hasProperty("xilinx_settings_script")) {
			xilinx_settings_script = escapeForShell(project.xilinx_settings_script)
			def xilinx_path = backticks(". $xilinx_settings_script >/dev/null ; echo \$XILINX", "bash")
			xil_tools = new File(xilinx_path).parentFile.parentFile
		} else if ("xil_tools" in env)
			xil_tools = new File(env["xil_tools"])
		else if ("XILINX" in env)
			xil_tools = new File(env["XILINX"]).parentFile.parentFile
		else if ("XILINX_SETTINGS_SCRIPT" in env) {
			xilinx_settings_script = escapeForShell(env["XILINX_SETTINGS_SCRIPT"])
			def xilinx_path = backticks(". $xilinx_settings_script >/dev/null ; echo \$XILINX", "bash")
			xil_tools = new File(xilinx_path).parentFile.parentFile
		} else if (project.hasProperty("xilinx_version"))
			xil_tools = path("/opt/Xilinx", project.xilinx_version)
		else if ("XILINX_VERSION" in env)
			xil_tools = path("/opt/Xilinx", env["XILINX_VERSION"])
		else
			xil_tools = new File("/opt/Xilinx/14.6")

		if (!xilinx_settings_script)
			xilinx_settings_script = path(xil_tools, "ISE_DS", "settings64.sh")

		if (!xil_tools.isDirectory()) {
			logger.error(heredoc("""
				ERROR: Couldn't find the directory with Xilinx tools. Please install Xilinx ISE_DS
				  (Webpack will do) and tell me about the location. You have several options:
				- Set the environment variable XILINX=/path/to/ISE_DS/ISE
				- Set the environment variable XILINX_VERSION, if the tools live in /opt/Xilinx/\$XILINX_VERSION
				- Set the environment variable xil_tools to the directory that contains the ISE_DS directory
				  (This may not work with other scripts, so you may want to choose one of the other options.)
				"""))
			throw new GradleException("Couldn't find the directory with Xilinx tools.")
		}

		if (hasProperty("gnutools"))
			gnutools = project.gnutools
		else
			gnutools = path(xil_tools, "ISE_DS", "EDK", "gnu", "arm", "lin", "bin", "arm-xilinx-linux-gnueabi-")
		if (hasProperty("libc_dir"))
			libc_dir = project.libc_dir
		else
			libc_dir = path(gnutools.parentFile.parentFile, "arm-xilinx-linux-gnueabi", "libc")

		do_check_libc(libc_dir)

		reconos_config.withWriter { out ->
			out.writeLine("xil_tools=\"$xil_tools\"")
			out.writeLine("gnutools=\"$gnutools\"")
			out.writeLine("libc_dir=\"$libc_dir\"")
			out.writeLine("reconos_arch=\"zynq\"")
			out.writeLine("reconos_os=\"linux\"")
			out.writeLine("reconos_mmu=true")
			out.writeLine("")
			out.writeLine("export KDIR=\"$ROOT/linux-xlnx\"")
			out.writeLine("export PATH=\"$ROOT/u-boot-xlnx/tools:\$PATH\"")
		}
	}
}

def get_libc_dir_after_reconos_config() {
	return reconosConfig.libc_dir
}

ext.xilinxVersionCache = hasProperty("xilinx_version") ? xilinx_version : null
def determineXilinxVersionAfterReconosConfig() {
	if (!xilinxVersionCache)
		xilinxVersionCache = backticks(
			". ${reconosConfig.reconosConfigScriptEscaped} ; " +
			/xps -help|sed -n 's#^Xilinx EDK \([0-9]\+\.[0-9]\+\)\b.*$#\1#p'/, "bash")

	return xilinxVersionCache
}

def do_check_libc(libc_dir) {
	// make sure we have the most important libc files

	if (!libc_dir.isDirectory())
		throw new GradleException("$libc_dir must be set to the install directory of libc, but it doesn't exist")

	for (file_pattern in ["usr/bin/getent", "lib/libutil.so.*", "lib/libc.so.*", "lib/ld-linux.so.*",
				 "lib/libgcc_s.so.*", "lib/libcrypt.so.*", "usr/lib/libnss_files.so"]) {
		FileTree tree = fileTree(dir: libc_dir)
		tree.include file_pattern
		if (tree.isEmpty()) {
			logger.error(heredoc("""
				ERROR: \$libc_dir must be set to the install directory of libc
				       At least the file '$file_pattern' is missing.
				       Please make sure that you install a complete libc (e.g. eglibc)
				       at this location. You have to provide more than the files I ask for!
				       \$libc_dir is '$libc_dir'
				"""))
			throw new GradleException("libc is incomplete.")
		}
	}
}

task checkLibc {
	dependsOn reconosConfig

	//inputs.property("libcDir") { reconosConfig.libc_dir }

	doLast {
		do_check_libc(reconosConfig.libc_dir)
	}
}

task checkDigilentDriverSimple {
	dependsOn reconosConfig

	doLast {
		if (project.sh_test("find ~/.cse -name libCseDigilent.so >/dev/null") != 0) {
			logger.warning(heredoc("""
				WARNING: I cannot find the Digilent JTAG driver in ~/.cse. It may live in another location.
				         If you are sure that it works, you can ignore this warning. You can run these commands to
				         install it (adapt the path as appropriate):
				           cd /opt/Xilinx/14.7/ISE_DS/ISE/bin/lin64/digilent
				           sudo ./install_digilent.sh
				           sudo chown -R "$USER" ~/.cse
				           sudo cp -r ~/.cse ~some_user/
				           sudo chown -R some_user ~some_user/.cse
				"""))
		}
	}
}

def doesFileBelongToRoot(file) {
	return backticks("stat -c %u ~/.cse").trim() == "0"
}

task checkDigilentDriver {
	dependsOn checkDigilentDriverSimple

	doLast {
		// The Digilent driver installer makes ~/.cse owned by root (or probably we shouldn't
		// have run it with sudo). xmd tries to put a temporary file into it and fails. Therefore,
		// we fix this.
		def env = System.getenv()
		def cse_dir = path(env["HOME"], ".cse")
		if (cse_dir.exists() && doesFileBelongToRoot(cse_dir) && env["USER"] != "root") {
			// try to fix permissions
			logger.warn("Permissions on $cse_dir are wrong (it belongs to root). I will try to fix that.")
			sh('chown -R "$USER" ~/.cse')
		}
	}
}

task check {
	dependsOn checkSubmodules, checkLibc, checkHostIp, checkDigilentDriver
}

def cleanRepository(dir) {
	if (!rootPath(dir, ".git").exists())
		throw new GradleException("'$dir' is not the root of a git repository")
	sh('cd ' + escapeForShell(rootPath(dir)) + ' && git reset --hard && git clean -f -x -d')
}

def cleanWithDistclean(dir) {
	dir = escapeForShell(file(dir))
	sh("cd $dir ; [ -e \"Makefile\" ] && make distclean || true")
}

task cleanUboot    << { cleanRepository("u-boot-xlnx") }
task cleanKernel   << { cleanRepository("linux-xlnx") }
task cleanBusybox  << { cleanRepository("busybox") }
task cleanDropbear << { cleanWithDistclean("dropbear") }
task cleanReconos  << { cleanRepository("reconos") }
task cleanRootfs(type: Delete) { delete ROOTFS }

task clean {
	dependsOn cleanUboot, cleanKernel, cleanBusybox, cleanDropbear, cleanReconos, cleanRootfs
}

task patchUboot(type: Exec) {
	commandLine "sh", "-c", "patch -N -p1 <${escapeForShell(path(FILES, 'u-boot-xlnx-zynq.patch'))}"

	workingDir file("u-boot-xlnx")

	mustRunAfter cleanUboot

	doFirst {
		def uboot_dir = escapeForShell(file("u-boot-xlnx"))
		sh("cd $uboot_dir && git checkout include/configs/zynq_common.h include/configs/zynq_zed.h")
	}

	inputs.file path(FILES, 'u-boot-xlnx-zynq.patch')
	outputs.files { fileTree(file("u-boot-xlnx")) { include "include/configs/zynq_common.h", "include/configs/zynq_zed.h" } }
}

def sedTask(name, expr, file, configClosure=null) {
	if (expr instanceof Collection) {
		expr = expr.collect { e -> "-e" + e }
	} else
		expr = [expr]

	file = project.file(file)
	def file_for_shell = escapeForShell(file)

	task(name, type: Exec) {
		commandLine(["sed", "-i"] + expr + [file])

		//inputs.file file  // task is not up-to-date, if output changes, so we don't need it as input
		outputs.file file
		inputs.property "sed-expressions", expr
	}
	if (configClosure)
		tasks[name].configure(configClosure)
}

sedTask("applyConfigToUboot", [
		"s/^#define CONFIG_IPADDR\\b.*\$/#define CONFIG_IPADDR   $board_ip/",
		"s/^#define CONFIG_SERVERIP\\b.*\$/#define CONFIG_SERVERIP $host_ip/",
		"s/\\bethaddr=[0-9a-fA-F:]\\+\\\\0/ethaddr=$board_mac_address\\\\0/"],
		"u-boot-xlnx/include/configs/zynq_common.h") {
	mustRunAfter patchUboot

	requiredProperty "board_ip"
	requiredProperty "host_ip"
	requiredProperty "board_mac_address"
}

def crosscompileMakeTask(name, targets, configClosure=null) {
	def parallel_processes = hasProperty("parallel_compilation_processes") ? parallel_compilation_processes : 4
	targets = escapeForShell(targets)
	task(name, type: Exec) {
		commandLine "bash", "-c", ". ${reconosConfig.reconosConfigScriptEscaped} && make -j$parallel_processes $targets"

		recommendedProperty "parallel_compilation_processes"

		dependsOn reconosConfig
	}
	if (configClosure)
		tasks[name].configure(configClosure)
}

def eachDirRecurseIncludingSelf(directory, closure) {
	closure(directory)
	directory.eachDirRecurse(closure)
}

def filesInGit(directory) {
	// I would use a fileTree to find .gitignore files, but fileTree seems to ignore hidden files.
	// def gitignoreFiles = fileTree(directory).include("**/.gitignore")
	directory = file(directory)
	return fileTree(directory) {
		eachDirRecurseIncludingSelf(directory) { subdir ->
			def gitignoreFile = new File(subdir, ".gitignore")
			if (gitignoreFile.exists()) {
				//println(gitignoreFile)
				def gitignorePath = (subdir.getPath() + "/").substring(directory.getPath().size()+1)
				gitignoreFile.eachLine { line ->
					if (line ==~ /^\s*#.*/ || line ==~ /^\s*$/) {
						// ignore
					} else {
						line = line.trim()
						String excludePattern
						if (line.startsWith("/")) {
							excludePattern = gitignorePath + line.substring(1)
						} else {
							excludePattern = gitignorePath + "**/" + line
						}
						//println("exclude: " + excludePattern)
						exclude excludePattern
					}
				}
			}
		}
	}
}

crosscompileMakeTask("compileUboot", "zynq_zed") {
	workingDir file("u-boot-xlnx")

	dependsOn patchUboot, applyConfigToUboot

	inputs.files filesInGit("u-boot-xlnx")
	outputs.files fileTree("u-boot-xlnx") {
		//include "*.o", "*.su"
		include "u-boot"		// used by downloadImagesToZynq
		include "tools/mkimage"	// used by compileKernelImage

		// some more files (but not all)
		include "u-boot.bin"
		include "u-boot.lds"
		include "u-boot.map"
		include "u-boot.srec"
		include "System.map"
		include "tools/gen_eth_addr", "tools/img2srec", "tools/kernel-doc/docproc",
			"tools/mkenvimage", "tools/mkimage", "tools/proftool"

	}
}

crosscompileMakeTask("configureKernel", "xilinx_zynq_defconfig") {
	workingDir file("linux-xlnx")

	mustRunAfter cleanKernel
}
crosscompileMakeTask("compileKernelImage", ["uImage", "LOADADDR=0x00008000"]) {
	workingDir file("linux-xlnx")
	dependsOn configureKernel
	// U-boot has the mkimage tool we need to package the kernel, so we have to build that first
	dependsOn compileUboot

	inputs.files filesInGit("linux-xlnx")
	inputs.file rootPath("linux-xlnx", ".config")
	outputs.files fileTree("linux-xlnx") {
		include "arch/arm/boot/uImage"
		include "scripts/dtc/dtc"	//TODO is it build by this?
	}
}
crosscompileMakeTask("compileKernelModules", ["modules"]) {
	workingDir file("linux-xlnx")
	dependsOn configureKernel
	shouldRunAfter compileKernelImage

	inputs.files filesInGit("linux-xlnx")
	inputs.file rootPath("linux-xlnx", ".config")
	outputs.files fileTree("linux-xlnx") {
		include "**/*.ko"
		include "**/modules.order", "**/modules.builtin"
	}
}

task compileKernel() {
	dependsOn configureKernel, compileKernelImage, compileKernelModules
}

task copyBusyboxConfig(type: Copy) {
	from(FILES) {
		include "busybox-config"
		rename "busybox-config", ".config"
	}
	into rootPath("busybox")

	mustRunAfter cleanBusybox
}

sedTask("applyConfigToBusybox", "s#^CONFIG_PREFIX=.*#CONFIG_PREFIX=\\\"${ROOTFS.toString().replace("#", "\\#")}\\\"#",
		rootPath("busybox", ".config")) {
	dependsOn copyBusyboxConfig
}

crosscompileMakeTask("compileBusybox", []) {
	dependsOn copyBusyboxConfig, applyConfigToBusybox
	workingDir rootPath("busybox")

	inputs.files filesInGit("busybox")
	outputs.files fileTree("busybox") {
		include "busybox"
		include "busybox.links"
		include "**/*.a"
	}
}

ext._getCrosscompileEnvvarAfterReconosConfig_cache = null
def getCrosscompileEnvvarAfterReconosConfig() {
	if (_getCrosscompileEnvvarAfterReconosConfig_cache != null)
		return _getCrosscompileEnvvarAfterReconosConfig_cache

	def value = backticks(". ${reconosConfig.reconosConfigScriptEscaped} >/dev/null ; echo -n \"\$CROSS_COMPILE\"", "bash")
	if (value == "")
		throw new GradleException("\$CROSS_COMPILE is empty after running the reconOS config script")

	_getCrosscompileEnvvarAfterReconosConfig_cache = value
	return value
}

def getCrosscompileHostSpecAfterReconosConfig() {
	// get CROSS_COMPILE environment variable and remove path and trailing minus
	def crosscompile = new File(getCrosscompileEnvvarAfterReconosConfig()).getName().trim()
	return (crosscompile =~ /-$/).replaceFirst("")
}

def getCrosscompileToolchainDirAfterReconosConfig() {
	return new File(getCrosscompileEnvvarAfterReconosConfig()).getParentFile()
}

def configureDropbearCommandline() {
	def host = getCrosscompileHostSpecAfterReconosConfig()
	return ["./configure", "--prefix=$ROOTFS", "--host=$host",
		"--enable-bundled-libtom", "--disable-utmp", "--disable-zlib"]
}

task configureDropbear(type: Exec) {
	dependsOn reconosConfig
	workingDir rootPath("dropbear")

	inputs.files fileTree("dropbear") {
		include "config*"
		exclude "config.h" ; exclude "config.log" ; exclude "config.status"
	}
	inputs.property("commandLine") { configureDropbearCommandline() }
	outputs.file file("dropbear/Makefile")
	outputs.file file("dropbear/config.h")

	doFirst {
		commandLine configureDropbearCommandline()
	}

	mustRunAfter cleanDropbear
}

task applyConfigToDropbear {
	// We could modify options.h

	dependsOn configureDropbear
}

crosscompileMakeTask("compileDropbear", []) {
	workingDir rootPath("dropbear")
	prependPATH getCrosscompileToolchainDirAfterReconosConfig()

	dependsOn applyConfigToDropbear

	inputs.files fileTree("dropbear") {
		exclude "**/*.log", "**/*.o", "**.a", "**/*.obj", "**/*.exe", "**/*.lib", "**/*.dll"
		exclude "**/*.da", "**/*.bb", "**/*.bbg", "**/*.prof", "**/*.gcov", "**/*~"
		exclude "**/*.ps", "**/*.pdf", "**/.xvpics"
		exclude "dropbear", "dbclient", "dropbearkey", "dropbearconvert", "scp", "scp-progress", "dropbearmulti"

		// removed by distclean, but nonetheless input to compile:
		// config.h, Makefile

		exclude(["test", "ltmtest", "mpitest", "mtest/mtest", "mtest/mtest.exe", "tommath.tex"].collect({
			item -> path("libtommath", item).toString()
		}))
		def excludeInLibtommathEtc = ["pprime", "tune", "mersenne", "drprime", "tune86", "tune86l", "mont",
			"2kprime", "pprime.dat"]
		excludeInLibtommathEtc = excludeInLibtommathEtc.collect { item -> path("libtommath", "etc", item).toString() }
		exclude(*excludeInLibtommathEtc)
		exclude "**/*.dyn", "**/*.dpi", "**/*.lo", "**/*.la"
		exclude "**/*.bat", "**/*.pdf"
		exclude "**/.libs"
	}
	outputs.files fileTree("dropbear") {
		include "dropbear", "dbclient", "dropbearkey", "dropbearconvert"
		// include "scp", "scp-progress", "dropbearmulti"
	}
}

crosscompileMakeTask("compileReconosDriver", []) {
	workingDir rootPath("reconos", "linux", "driver")
}
crosscompileMakeTask("compileReconosLib", []) {
	workingDir rootPath("reconos", "linux", "lib")
}
crosscompileMakeTask("compileReconosDemoLinux", []) {
	ext.demo = "sort_demo"
	ext.demoDir = rootPath("reconos", "demos", demo)
	workingDir path(demoDir, "linux")

	//requiredProperty "demo"

	dependsOn compileReconosLib
}

def demoHwDir(...suffix) {
	def demoDir = compileReconosDemoLinux.demoDir
	return rootPath(demoDir, "hw", *suffix)
}

def getVariablesFromShell(cmd, variablenames) {
	variablenames.each { varname ->
		cmd += " && echo \"${varname}=\$${varname}\""
	}
	def values = [:]
	backticks(cmd, "bash").split("\n")*.split("=", 2).each { pair ->
		values[pair[0]] = pair[1]
	}
	return values
}

ext._reconosInfoCache = null
def getReconosInfo(varname=null) {
	if (_reconosInfoCache == null) {
		def cmd = ". ${reconosConfig.reconosConfigScriptEscaped} >/dev/null"
		_reconosInfoCache = getVariablesFromShell(cmd, ["RECONOS", "RECONOS_ARCH", "RECONOS_OS"])
	}

	if (varname == null)
		return _reconosInfoCache
	else if (_reconosInfoCache.containsKey(varname))
		return _reconosInfoCache[varname]
	else
		throw new GradleException("invalid reconOS variable name: $varname")
}
ext._reconosConfigurationFileCache = [:]
def getReconosConfigFileInfo(configfile, varname=null) {
	configfile = new File(configfile.toString()).canonicalPath
	if (!_reconosConfigurationFileCache.containsKey(configfile)) {
		def cmd = ". ${reconosConfig.reconosConfigScriptEscaped} >/dev/null && . ${escapeForShell(configfile)} >/dev/null"
		def interesting_vars = ["base_design", "num_static_hwts", "static_hwts", "num_reconf_regions",
			"num_reconf_hwts", "reconf_hwts"]
		_reconosConfigurationFileCache[configfile] = getVariablesFromShell(cmd, interesting_vars)
	}

	if (varname == null)
		return _reconosConfigurationFileCache[configfile]
	else if (_reconosConfigurationFileCache[configfile].containsKey(varname))
		return _reconosConfigurationFileCache[configfile][varname]
	else
		throw new GradleException("invalid reconOS config variable name: $varname")
}

class LazyValue {
	private def value
	private def closure

	public LazyValue(closure) {
		this.closure = closure
	}

	public def getValue() {
		if (this.closure != null) {
			this.value = this.closure()
			this.closure = null
		}

		return this.value
	}

	@Override
	public String toString() {
		return this.getValue()
	}
}
def lazyValue(closure) {
	return new LazyValue(closure)
}

task prepareReconosDemoHardware(type: Exec) {
	def demo = compileReconosDemoLinux.demo
	workingDir demoHwDir()

	dependsOn reconosConfig
	mustRunAfter cleanReconos

	//TODO get design for 14.7 from Christoph
	//     Then set version before executing the script.
	//     sed -i 's/zedboard_minimal_[0-9].*/zedboard_minimal_'"$XILINX_VERSION"'/' setup_zynq
	//TODO Make sure that this change doesn't cause unnecessary recompiles.

	def setup_script = demoHwDir("setup_zynq")
	def base_design = lazyValue { getReconosConfigFileInfo(setup_script, "base_design") }
	def RECONOS_ARCH = lazyValue { getReconosInfo("RECONOS_ARCH") }
	def RECONOS_OS   = lazyValue { getReconosInfo("RECONOS_OS")   }
	def RECONOS      = lazyValue { getReconosInfo("RECONOS")      }
	def edk_dir = lazyValue { demoHwDir("edk_${RECONOS_ARCH.value}_${RECONOS_OS.value}") }
	def usedHwThreads = lazyValue {
		def all_hwts = getReconosConfigFileInfo(setup_script, "static_hwts") + " " +
			getReconosConfigFileInfo(setup_script, "reconf_hwts")
		all_hwts = all_hwts.tokenize()*.replaceFirst(/#.*$/, "").unique()
	}

	commandLine "bash", "-c", ". ${reconosConfig.reconosConfigScriptEscaped} && " +
		"rm -rf edk_${RECONOS_ARCH}_${RECONOS_OS} && " +
		"bash reconos_setup.sh setup_zynq"

	inputs.file setup_script
	inputs.property("RECONOS_ARCH") { getReconosInfo("RECONOS_ARCH") }
	inputs.property("RECONOS_OS"  ) { getReconosInfo("RECONOS_OS")   }
	inputs.property("base_design" ) { base_design.value }
	inputs.dir { path(RECONOS.value, "tools") }
	inputs.dir { path(RECONOS.value, "designs", "${RECONOS_ARCH.value}_${RECONOS_OS.value}_${base_design.value}") }
	inputs.dir { path(RECONOS.value, "pcores") }
	inputs.files { fileTree(demoHwDir("hw")) { usedHwThreads.value.each { hwt -> include hwt } } }
	outputs.dir {
		fileTree(edk_dir.toString()) {
			exclude "hdl", "implementation", "platgen.*", "revup", "synthesis", "__xps"
			exclude "system.mhs.orig", "ps_clock_registers.log", "system.log"
			exclude "device_tree.dts", "device_tree.dtb"

			// created by this task, but changed later
			exclude "system_incl.make", "system.make", "system.xmp"
		}
	}
}

import org.gradle.process.internal.ExecActionFactory
def run_xps(project, commands, workingDir=null, task=null) {
	project = escapeForShell(project)
	commands = escapeForShell(commands + " ; exit")
	def cmd = "echo $commands | xps -nw $project"
	cmd = ". ${reconosConfig.reconosConfigScriptEscaped} && " + cmd
	if (workingDir)
		cmd = "cd " + escapeForShell(workingDir) + " && " + cmd
	// try at most 3 times
	for (i in [1,2,3]) {
		def res = sh_test(cmd, "bash")
		if (res == 0)
			return
		else if (res == 139)
			logger.warn("xps failed. This may be due to a segfault, so we try again.")
		else
			break
	}
	// Either it didn't fail with a segfault or it failed too often
	throw new GradleException("System command returned non-zero status (return value is $res): ${cmd.inspect()}")
}

task compileReconosDemoHardwareBitstream {
	dependsOn reconosConfig, prepareReconosDemoHardware

	inputs.files { prepareReconosDemoHardware.outputs }
	inputs.property("RECONOS_ARCH") { getReconosInfo("RECONOS_ARCH") }
	inputs.property("RECONOS_OS"  ) { getReconosInfo("RECONOS_OS")   }

	def RECONOS_ARCH = lazyValue { getReconosInfo("RECONOS_ARCH") }
	def RECONOS_OS   = lazyValue { getReconosInfo("RECONOS_OS")   }
	def edk_dir = lazyValue { demoHwDir("edk_${RECONOS_ARCH.value}_${RECONOS_OS.value}") }
	outputs.files { fileTree(path(edk_dir, "implementation")) { include "*.bit" } }

	doLast {
		def demo = compileReconosDemoLinux.demo
		def workingDir = demoHwDir("edk_zynq_linux")

		//TODO keep __xps folder in git and use `make -f system.make bits`
		//TODO This sometimes fails with a segfault (prints "Segmentation fault" and
		//     exits with status 35584). We should run it again in that case.

		run_xps("system", "run bits", workingDir, compileReconosDemoHardwareBitstream)
	}
}

task copyReconosDeviceTree(type: Copy) {
	def demo = compileReconosDemoLinux.demo
	from path(FILES, "device_tree.dts")
	into demoHwDir("edk_zynq_linux")
}

def nfsMountForDeviceTree() {
	if (hasProperty("nfs_mount"))
		return project.nfs_mount
	else
		return "$host_ip:$local_nfs_root"
}

sedTask("applyConfigToReconosDeviceTree", [
		/s#\(nfsroot=[0-9.]\+\):[^,]*,tcp#nfsroot=/ + nfs_mount + /,tcp#/,
		/s#\bip=[0-9.]\+:#ip=/ + board_ip + /:#/],
		demoHwDir("edk_zynq_linux", "device_tree.dts")) {
	dependsOn copyReconosDeviceTree
	requiredProperty "board_ip"
	requiredProperty "nfs_mount"
}

task prepareReconosDeviceTree {
	dependsOn copyReconosDeviceTree, applyConfigToReconosDeviceTree
}

task compileReconosDeviceTree(type: Exec) {
	//TODO depend on the task that builds dtc
	dependsOn reconosConfig, prepareReconosDeviceTree, prepareReconosDemoHardware

	workingDir demoHwDir("edk_zynq_linux")

	commandLine rootPath("linux-xlnx", "scripts", "dtc", "dtc"),
		"-I", "dts", "-O", "dtb", "-o", "device_tree.dtb", "device_tree.dts"
}

task compileReconosDemoHardware {
	dependsOn compileReconosDemoHardwareBitstream, compileReconosDeviceTree
}

task compileReconos {
	dependsOn compileReconosDriver, compileReconosLib, compileReconosDemoLinux, compileReconosDemoHardware
}

task compile {
	dependsOn compileUboot, compileKernel, compileBusybox, compileDropbear, compileReconos
}

crosscompileMakeTask("installBusybox", ["CONFIG_PREFIX=$ROOTFS", "install"]) {
	workingDir rootPath("busybox")

	dependsOn compileBusybox
	shouldRunAfter compile

	doLast {
		def tempfile_not_ignored = rootPath("busybox",  "busybox.links")
		def tempfile_ignored     = rootPath("busybox", ".busybox.links")
		if (tempfile_not_ignored.exists()) {
			// hide this file, so it doesn't make the git dirty
			// (unfortunately, it is not ignored in .gitignore)
			tempfile_not_ignored.renameTo(tempfile_ignored)
		}
	}
}

def get_init_info(file, key) {
	project.file(file).withReader { rd ->
		boolean inInitInfo = false
		String line = null
		while (line = rd.readLine()) {
			if (line ==~ /^#+\s*BEGIN INIT INFO\s*$/)
				inInitInfo = true
			else if (line ==~ /^#+\s*END INIT INFO\s*$/)
				return null
			else if (inInitInfo) {
				def m = (line =~ /(?i)^#\s*/ + escapeForRegex(key) + /:\s*(.*)$/)
				if (m)
					return m.group(1).trim()
			}
		}
		return null
	}
}

def get_order(file, start_or_stop) {
	def order = get_init_info(file, "${start_or_stop}-order")
	if (order)
		return order
	else {
		order = get_init_info(file, "order")

		if (start_or_stop == "start")
			return order
		else {
			if (order)
				return String.format("%02d", 100 - order.toInteger())
			else
				return ""
		}
	}
}

import groovy.io.FileType

def symlink(target, link) {
	target = FileLinkAction.getRelativePath(file(target), file(link).parentFile)
	sh("ln -s ${escapeForShell(target)} ${escapeForShell(link)}")
}

def touch(file) {
	file.withWriterAppend { out -> out.write("") }
}

def chmod(file, permissions) {
	permissions = String.format("0%o", permissions)
	sh("chmod $permissions ${escapeForShell(file)}")
}

task installBaseSystem {
	requiredProperty "host_ip"

	doLast {
		for (dir in ["dev", "dev/pts",
				"etc", "etc/init.d", "etc/rc.d", "etc/default",
				"lib", "mnt", "opt", "proc", "root", "sys", "tmp",
				"var","var/run", "var/log"])
			path(ROOTFS, *dir.split("/")).mkdirs()

		def rc_script = path(ROOTFS, "etc", "rcS")
		project.copyFile(path(FILES, "startup-script.sh"), rc_script)
		chmod(rc_script, 0755)
		project.copyFile(path(FILES, "inittab"), path(ROOTFS, "etc", "inittab"))
		project.copyFile(path(FILES, "fstab"  ), path(ROOTFS, "etc", "fstab"  ))

		for (dir in ["init.d", "rc.d"]) {
			path(ROOTFS, "etc", dir).deleteDir()
			path(ROOTFS, "etc", dir).mkdir()
		}

		path(FILES, "init.d").eachFile(FileType.FILES) { initd_script ->
			def src = initd_script
			def name = src.name
			def dst = path(ROOTFS, "etc", "init.d", name)
			project.copyFile(src, dst)
			chmod(dst, 0755)

			def start_order = get_order(dst, "start")
			def stop_order  = get_order(dst, "stop")

			if (start_order)
				symlink(dst, path(ROOTFS, "etc", "rc.d", "S${start_order}${name}"))

			if (stop_order)
				symlink(dst, path(ROOTFS, "etc", "rc.d", "K${stop_order}${name}"))
		}

		path(ROOTFS, "etc", "default", "notify-host").withWriter { out ->
			out.writeLine("NOTIFY_HOST=" + escapeForShell(host_ip))
		}


		path(ROOTFS, "etc", "passwd").withWriter { out ->
			out.writeLine("root:x:0:0:root:/root:/bin/ash")
		}
		path(ROOTFS, "etc", "group").withWriter { out ->
			out.writeLine("root:x:0:")
		}

		// see http://cross-lfs.org/view/clfs-sysroot/arm/cross-tools/eglibc.html
		path(ROOTFS, "etc", "nsswitch.conf").withWriter { out ->
			out.write(heredoc("""
				passwd: files
				group: files
				shadow: files

				hosts: files dns
				networks: files

				protocols: files
				services: files
				ethers: files
				rpc: files
				"""))
		}
		
		project.copyFile(path("/etc/localtime"), path(ROOTFS, "etc", "localtime"))

		// eglibc doc (see above) suggest that we add `/usr/local/lib` and `/opt/lib`,
		// but we don't use them
		touch(path(ROOTFS, "etc", "ld.so.conf"))
	}
}

task installLibc(type: Copy) {
	dependsOn reconosConfig

	from { reconosConfig.libc_dir }
	into ROOTFS

	include "."
	exclude "usr/lib/locale"
	exclude "usr/include"

	// We do not copy all the locales (which are many times bigger than the whole rootfs), so we prepare
	// a list of the locales we do want.
	// Actually, there is more locale data in /usr/share/locale, but this is small, so we don't care.
	ext.included_locales = ["en_US", "en_US.utf8", "de_DE.utf8"]
	included_locales.each { locale ->
		include "usr/lib/locale/"+locale
	}
}

crosscompileMakeTask("installDropbearFiles", ["prefix="+ROOTFS, "install"]) {
	workingDir rootPath("dropbear")
	prependPATH getCrosscompileToolchainDirAfterReconosConfig()

	dependsOn compileDropbear
	shouldRunAfter compile

	inputs.files compileDropbear.outputs
	inputs.files fileTree("dropbear") { include "dropbear.8", "dropbearkey.1", "dbclient.1", "dropbearconvert.1" }
	outputs.files fileTree(ROOTFS) {
		include "bin/dbclient", "bin/dropbearkey", "bin/dropbearconvert"
		include "sbin/dropbear"
		include "share/man/**/dropbear*", "share/man/**/dbclient*"
	}
}

task installDropbearConfig {
	mustRunAfter installDropbearFiles

	def home_dir_for_board = path(ROOTFS, "root")
	def ssh_dir = path(home_dir_for_board, ".ssh")
	def authorized_keys = path(ssh_dir, "authorized_keys")
	def home_dir = System.getenv()["HOME"]
	def public_key_file = path("$home_dir", ".ssh", "id_rsa.pub")
	def shells_file = path(ROOTFS, "etc", "shells")

	inputs.file public_key_file
	inputs.property "HOME", home_dir
	outputs.dir ssh_dir
	outputs.file authorized_keys
	outputs.file shells_file

	doLast {
		ssh_dir.mkdirs()
		if (public_key_file.exists() && !authorized_keys.exists()) {
			def public_key = public_key_file.text
			authorized_keys.write(public_key)

			chmod(ssh_dir, 0755)
			chmod(authorized_keys, 0600)
		}

		def shells = ""
		if (shells_file.exists())
			shells = shells_file.text
		if (!(shells ==~ '^/bin/ash$')) {
			shells += "/bin/ash\n"
			shells_file.parentFile.mkdirs()
			shells_file.write(shells)
		}
	}
}

task installDropbear {
	dependsOn installDropbearFiles, installDropbearConfig
}

crosscompileMakeTask("installKernelModules", ["INSTALL_MOD_PATH="+ROOTFS, "modules_install"]) {
	workingDir rootPath("linux-xlnx")

	dependsOn compileKernelModules
}

task installReconos {
	dependsOn installKernelModules, compileReconosDriver, compileReconosDriver

	doLast {
		def KERNEL_RELEASE = path(ROOT, "linux-xlnx", "include", "config", "kernel.release").text.trim()
		def RECONOS_MODULE = "kernel/drivers/mreconos.ko"
		def MODULE_DIR = path(ROOTFS, "lib", "modules", KERNEL_RELEASE)
		def src = path(ROOT, "reconos", "linux", "driver", "mreconos.ko")
		def dst = path(MODULE_DIR, *RECONOS_MODULE.split("/"))
		project.copyFile(src, dst)
		path(MODULE_DIR, "modules.dep").withWriterAppend { out ->
			out.writeLine(RECONOS_MODULE + ": ")
		}
	}
}

task buildRootfs {
	dependsOn reconosConfig, installBusybox, installBaseSystem,
		installLibc, installDropbear, installKernelModules,
		installReconos

	doFirst {
		if (!ROOTFS.isDirectory())
			ROOTFS.mkdirs()
	}
}

task build {
	dependsOn compile, buildRootfs
}

task copyFilesToNfsRoot(type: Copy) {
	from ROOTFS
	into local_nfs_root

	requiredProperty "local_nfs_root"

	mustRunAfter buildRootfs
}

def fileAncestors(file) {
	def ancestors = []
	while (file != null) {
		ancestors.add(file)
		file = file.parentFile
	}
	return ancestors
}

task fixPermissionsInNfsRoot(type: Exec) {
	def authorized_keys_file = path(local_nfs_root, "root", ".ssh", "authorized_keys")
	commandLine("chown", "root:root", *fileAncestors(authorized_keys_file).take(3))

	mustRunAfter copyFilesToNfsRoot
	requiredProperty "local_nfs_root"
}

task warnAboutAdditionalFilesInNfsRoot {
	requiredProperty "local_nfs_root"

	mustRunAfter copyFilesToNfsRoot

	doLast {
		def exclude = [".ash_history", "dropbear", "motd", "log", "run", "lost+found"]
		def exclude_pattern = "/\\(" + exclude.collect(escapeForRegex).join("\\|") + "\\)\\(/\\|\$\\)"
		def exclude_filter = "grep -v " + escapeForShell(exclude_pattern)

		def list_files = { directory, listfile ->
			directory = escapeForShell(directory)
			listfile = escapeForShell(listfile)
			sh("cd $directory && find | $exclude_filter | sort >$listfile")
		}

		def files_in_rootfs = rootPath(temporaryDir, "files_in_rootfs")
		def files_in_nfsroot = rootPath(temporaryDir, "files_in_nfsroot")
		try {
			list_files(ROOTFS, files_in_rootfs)
			list_files(local_nfs_root, files_in_nfsroot)

			def files_in_rootfs_esc = escapeForShell(files_in_rootfs)
			def files_in_nfsroot_esc = escapeForShell(files_in_nfsroot)
			def res = sh_test("diff -y --suppress-common-lines $files_in_rootfs_esc $files_in_nfsroot_esc")
		} finally {
			if (files_in_rootfs.exists())
				files_in_rootfs.delete()
			if (files_in_nfsroot.exists())
				files_in_nfsroot.delete()
		}
	}
}

task updateNfsRoot {
	dependsOn copyFilesToNfsRoot, fixPermissionsInNfsRoot, warnAboutAdditionalFilesInNfsRoot
}

task createPs7InitFile(type: Copy) {
	//TODO we shouldn't have to provide this file - it should be in the reconos git
	def edk_project_dir = demoHwDir("edk_zynq_linux")
	from FILES
	into edk_project_dir
	include "ps7_init.tcl"
}

task downloadImagesToZynq(type: Exec) {
	//NOTE If this fails because it doesn't find the cable, install the cable drivers:
	//     cd $XILINX/bin/lin64/digilent ; ./install_digilent.sh
	def edk_project_dir = demoHwDir("edk_zynq_linux")
	def command = escapeForShell(["bash", "zynq_boot_tftp.sh",
		path(ROOT, "linux-xlnx", "arch", "arm", "boot", "uImage"),
		path(edk_project_dir, "device_tree.dtb"),
		path(edk_project_dir, "ps7_init.tcl"),
		path(ROOT, "u-boot-xlnx", "u-boot")])
	commandLine "bash", "-c", ". ${reconosConfig.reconosConfigScriptEscaped} && $command"
	workingDir ROOT

	doLast {
		logger.info("The board should be booting, now.")
		logger.info("If you abort u-boot for some reason, enter 'jtagboot' or 'bootm 0x3000000 - 0x2A00000'.")
	}

	mustRunAfter checkHostIp, checkDigilentDriver, reconosConfig, updateNfsRoot
	dependsOn compileKernelImage, compileReconosDeviceTree, compileUboot
	dependsOn createPs7InitFile
}

def run_xmd(commands) {
	commands = escapeForShell(commands.toString() + " ; exit")
	sh("echo $commands | xmd")
}

task downloadBitfileToZynq {
	doLast {
		def edk_project_dir = demoHwDir("edk_zynq_linux")
		def bitfile = path(edk_project_dir, "implementation", "system.bit")
		run_xmd("fpga -f ${escapeForShell(bitfile)}")
	}
	mustRunAfter checkHostIp, checkDigilentDriver, reconosConfig, updateNfsRoot
	dependsOn compileReconosDemoHardwareBitstream
	dependsOn createPs7InitFile
	shouldRunAfter downloadImagesToZynq
}

task waitForBootingBoard {
	mustRunAfter downloadImagesToZynq, downloadBitfileToZynq
	requiredProperty "host_ip"

	doLast {
		logger.info("Wait for the board to contact us...")
		if (sh_test("timeout 30 nc -l ${escapeForShell(host_ip)} 12342") != 0) {
			logger.error(
				"ERROR: The board didn't send the 'done' message within 30 seconds.")

			if (!can_ping(host_ip)) {
				logger.error(heredoc("""
					ERROR: I cannot ping $host_ip, so I think for some reason your IP got reset.
					  Please make sure that you use an ethernet switch (i.e. don't
					  directly connect your PC to the board) or make sure that the IP
					  settings survive a reset of the ethernet connection (i.e. set them
					  in NetworkManager or similar).
					"""))
				throw new GradleException("I cannot ping the local host ($host_ip).")
			}

			if (!can_ping(board_ip)) {
				logger.error(
					"I cannot ping the board ($board_ip). This is a bad sign. I will try to continue anyway.")
			} else {
				logger.warn("I didn't get any reply from the board. I will try to continue anyway. " +
					"However, you should fix the underlying problem, so I won't waste time waiting " +
					" until the timeout.")
			}
		}
	}
}

task bootZynq {
	dependsOn downloadImagesToZynq, downloadBitfileToZynq, waitForBootingBoard
}

def getBoardPubkey(keytype) {
	def infofile = path(local_nfs_root, "etc", "dropbear", "dropbear_${keytype}_host_key.info")
	return (infofile.text =~ /(?m)^ssh-\S+\s+\S+/)[0]
}

def pubkeyIsInKnownHosts(hostname, pubkey) {
	return 0 == sh_test("ssh-keygen -F ${escapeForShell(hostname)} | grep -q ${escapeForShell(pubkey)}")
}

task prepareSsh {
	dependsOn checkHostIp
	mustRunAfter bootZynq

	requiredProperty "local_nfs_root"

	doLast {
		def pubkey = getBoardPubkey("rsa")

		if (pubkey && !pubkeyIsInKnownHosts(board_ip, pubkey)) {
			// board key is not in known_hosts, so we remove any old ones and add the new one
			sh("ssh-keygen -R ${escapeForShell(board_ip)}")
			def home_dir = System.getenv()["HOME"]
			path(home_dir, ".ssh", "known_hosts").withWriterAppend { out ->
				out.write("$board_ip $pubkey\n")
			}
			// re-hash the file
			sh("ssh-keygen -H")
		}
	}
}

def ssh_zynq_special(command, redirects="") {
	sh("ssh -o PubkeyAuthentication=yes root@${board_ip} ${escapeForShell(command)} ${redirects}")
}

def ssh_zynq(...command) {
	return ssh_zynq_special(command)
}

def copy_to_zynq(local_file, file_on_zynq) {
	ssh_zynq_special("cat >${escapeForShell(file_on_zynq)}", "<${escapeForShell(local_file)} >/dev/null")
}

task sshShell {
	dependsOn prepareSsh

	doLast {
		ssh_zynq()
	}
}

task runDemo {
	dependsOn prepareSsh
	
	doLast {
		def demo_args = "2 2 50"
		def demo = compileReconosDemoLinux.demo
		def demo_binary = path(compileReconosDemoLinux.demoDir, "linux", demo)
		def demo_on_target = path("/tmp", demo)
		copy_to_zynq(demo_binary, demo_on_target)

		demo_on_target = escapeForShell(demo_on_target)
		ssh_zynq("chmod +x $demo_on_target && $demo_on_target $demo_args")
	}
}

task bootZynqAndRunDemo {
	dependsOn updateNfsRoot, bootZynq, runDemo
}

task compileAndRun {
	dependsOn compile, buildRootfs, bootZynqAndRunDemo
}

task cleanCompileAndRun {
	dependsOn clean, compileAndRun
}

tasks.all { task ->
	task.doLast {
		if (!file("linux-xlnx/Makefile").exists())
			throw new GradleException("We lost linux-xlnx/Makefile !!!")
	}
}
