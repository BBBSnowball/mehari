def distutilsPlatformBuildDir() {
	return ["python", "-c", 'import sys, distutils.util ; print "build/lib.%s-%s" % (distutils.util.get_platform(), sys.version[0:3])'].execute().text
}

task compilePythonCTemplate(type: Exec) {
	workingDir "python-ctemplate"

	commandLine "python", "setup.py", "build", "--build-platlib="+distutilsPlatformBuildDir()

	inputs.dir "python-ctemplate/src"
	inputs.file "python-ctemplate/setup.py"
	outputs.file "python-ctemplate/" + distutilsPlatformBuildDir()  + "/ctemplate.so"
}

task installPythonCTemplate(type: Copy) {
	from "python-ctemplate/" + distutilsPlatformBuildDir()
	into pythonInstallPath

	dependsOn compilePythonCTemplate
}

task testPythonCTemplate(type: Exec) {
	workingDir "python-ctemplate"

	commandLine "python", "tests/test.py"

	environment "PYTHONPATH", file(pythonInstallPath).absolutePath

	dependsOn installPythonCTemplate
	mustRunAfter "compile"

	inputs.files installPythonCTemplate.outputs
	inputs.dir "python-ctemplate/test"
	outputs.file "python-ctemplate/python-ctemplate.tap"
}

task installPythonHelpers(type: SymLink) {
	from "python-helpers"
	into "_install"
	include "**"
	exclude "*.bak"
	exclude "*.pyc"
}

task cleanGTest (type: Delete) { delete { tasks["extractGTestSource"   ].targetDir } }

task extractGTestSource(type: FetchAndExtractSourceTask) {
	artifact "com.google.code.googletest:gtest:1.7.0:sources@tar.bz2"
	into "_gtest"

	mustRunAfter cleanGTest

	inputs.property "taskVersion", "1.1"

	doLast {
		// add -fPIC flag
		def cmake_file = rootPath(targetDir, "CMakeLists.txt")
		chmod(cmake_file, 0644)
		exec {
			commandLine "sed", "-i", 's/^\\(cxx_library(\\w\\+ "\\\${cxx_strict}\\)[^"]*"/\\1 -fPIC"/', cmake_file
		}
	}
}

task prepareGTest(type: Exec) {
	commandLine "cmake", "."
	workingDir extractGTestSource.targetDir

	dependsOn extractGTestSource

	inputs.files  fileTree(extractGTestSource.targetDir).include("**/CMakeLists.txt", "cmake/internal_utils.cmake")
	outputs.files fileTree(extractGTestSource.targetDir).include("cmake_install.cmake", "CMakeCache.txt", "Makefile",
		"CMakeFiles/**/*.cmake", "CMakeFiles/**/*.make", "CMakeFiles/**/Makefile*")
}

task compileGTest(type: Exec) {
	commandLine "make"
	workingDir extractGTestSource.targetDir

	dependsOn prepareGTest

	inputs.files  fileTree(extractGTestSource.targetDir).include("Makefile", "src", "include")
	outputs.files fileTree(extractGTestSource.targetDir).include("libgtest*.a")
}

task installGTestHeaders(type: Copy) {
	from rootPath(extractGTestSource.targetDir, "include")
	from(".") {
		include "gtest_tap.h"
		rename { "gtest/tap.h" }
	}
	into rootPath("_install", "include")

	dependsOn compileGTest

	doFirst {
		// fix permissions of target files, so we can overwrite them
		fileTree(destinationDir).each { chmod(it, 0644) }
	}
}

task installGTestLibs(type: Copy) {
	from(rootPath(extractGTestSource.targetDir)) {
		include "*.a"
	}
	into rootPath("_install", "lib")

	dependsOn compileGTest
}

task installGTest {
	dependsOn installGTestHeaders, installGTestLibs
}

task cleanGMock (type: Delete) { delete { tasks["extractGMockSource"   ].targetDir } }

task extractGMockSource(type: FetchAndExtractSourceTask) {
	artifact "com.google.code.googletest:gmock:1.7.0:sources@tar.bz2"
	into "_gmock"

	mustRunAfter cleanGMock

	inputs.property "taskVersion", "1.1"

	doLast {
		// add gmock-only target and add -fPIC flag
		def cmake_file = rootPath(targetDir, "CMakeLists.txt")
		chmod(cmake_file, 0644)
		cmake_file.withWriterAppend { w ->
			w.writeLine("")
			w.writeLine('cxx_library(gmock-only "${cxx_strict} -fPIC" src/gmock-all.cc)')
			w.writeLine("")
		}
	}
}

task prepareGMock(type: Exec) {
	commandLine "cmake", "."
	workingDir extractGMockSource.targetDir

	dependsOn extractGMockSource

	inputs.files  fileTree(extractGMockSource.targetDir).include("cmake/internal_utils.cmake")
	outputs.files fileTree(extractGMockSource.targetDir).include("cmake_install.cmake", "CMakeCache.txt", "Makefile",
		"CMakeFiles/**/*.cmake", "CMakeFiles/**/*.make", "CMakeFiles/**/Makefile*", "CMakeLists.txt")
}

task compileGMock(type: Exec) {
	commandLine "make", "gmock-only"
	workingDir extractGMockSource.targetDir

	dependsOn prepareGMock, installGTest

	inputs.files  fileTree(extractGMockSource.targetDir).include("Makefile", "src", "include")
	outputs.files fileTree(extractGMockSource.targetDir).include("libgmock*.a")
}

task installGMockHeaders(type: Copy) {
	from rootPath(extractGMockSource.targetDir, "include")
	into rootPath("_install", "include")

	dependsOn compileGMock
}

task installGMockLibs(type: Copy) {
	from(rootPath(extractGMockSource.targetDir)) {
		include "libgmock-only.a"
		rename { "libgmock.a" }
	}
	into rootPath("_install", "lib")

	dependsOn compileGMock

	doFirst {
		// fix permissions of target files, so we can overwrite them
		fileTree(destinationDir).each { chmod(it, 0644) }
	}
}

task installGMock {
	dependsOn installGMockHeaders, installGMockLibs, installGTest
}

task preparePivpav(type: Exec) {
	ext.sourceDir = rootPath("pivpav", "api", "wrapper")

	commandLine "cmake", "-DCMAKE_BUILD_TYPE=Debug",
		"-DCMAKE_INSTALL_PREFIX=${file("_install")}",
		sourceDir
	workingDir rootPath("pivpav", "api", "wrapper", "build")

	doFirst { workingDir.mkdirs() }

	outputs.file rootPath("pivpav", "api", "wrapper", "build", "Makefile")
}

task compilePivpav(type: Exec) {
	commandLine "make"
	workingDir preparePivpav.workingDir

	inputs.files fileTree(preparePivpav.sourceDir) {
		include "**/*.cpp", "**/*.h", "CMakeLists.txt"
	}
	outputs.files path(workingDir, "libpivpav.so"),
		path(workingDir, "libwrapper.so"),
		path(workingDir, "libwrapper_static.a")

	dependsOn preparePivpav
}

task installPivPavLibraries(type: Copy) {
    from(compilePivpav.workingDir) {
        include '*.so'
        include '*.a'
    }
	into(rootPath("_install", "lib"))

	dependsOn compilePivpav
}

task installPivPavHeaders(type: Copy) {
    from(rootPath("pivpav", "api", "include")) {
        include '*.h'
        include '*.hpp'
    }
	into(rootPath("_install", "include", "pivpav"))

	dependsOn compilePivpav
}

task installPivPav {
	dependsOn installPivPavHeaders, installPivPavLibraries
}


def subproject_names = ["vhdlgen"]

["compile", "install", "test"].each { name ->
	task(name) {
		dependsOn tasks.findAll { task -> task.name.startsWith(name) && task.name != name }

		subproject_names.each { subproject ->
			dependsOn "$subproject:$name"
		}
	}
}
